<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:20160813_Canvas基础讲义_v1</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<p>Canvas 基础讲义</p>
<h1 id="-">基本篇</h1>
<h2 id="-canvas">什么是 Canvas</h2>
<p>canvas 是 HTML5 提供的一个用于展示绘图效果的标签. canvas 原意画布, 帆布.
在 HTML 页面中用于展示绘图效果. 最早 canvas 是苹果提出的一个方案, 
今天已经在大多数浏览器中实现.</p>
<pre><code>canvas 英 [&#39;kænvəs]  美 [&#39;kænvəs]   帆布 画布
</code></pre><h3 id="canvas-">canvas 的基本用法</h3>
<p><strong>基本语法</strong></p>
<pre><code>    &lt;canvas&gt;&lt;/canvas&gt;
</code></pre><ol>
<li>使用 canvas 标签, 即可在页面中开辟一格区域. 可以设置其 width 和 height 设置该区域的尺寸.</li>
<li>默认 canvas 的宽高为 300 和 150.</li>
<li>不要使用 CSS 的方式设置宽高, 应该使用 HTML 属性.</li>
<li>如果浏览器不支持 canvas 标签, 那么就会将其解释为 div 标签. 因此常常在 canvas 中嵌入文本, 以提示用户浏览器的能力.</li>
<li>canvas 的兼容性非常强, 只要支持该标签的, 基本功能都一样, 因此不用考虑兼容性问题.</li>
<li>canvas 本身不能绘图. 是使用 JavaScript 来完成绘图. canvas 对象提供了各种绘图用的 api.</li>
</ol>
<p><strong>canvas 的使用领域</strong></p>
<p>canvas 的使用领域很多:</p>
<ol>
<li>游戏</li>
<li>可视化数据(重点)</li>
<li>banner 广告</li>
<li>多媒体</li>
<li>未来<ul>
<li>模拟仿真</li>
<li>远程操作</li>
<li>图形编辑</li>
</ul>
</li>
</ol>
<h3 id="-">我们的课程目标</h3>
<ol>
<li>不是为了做游戏</li>
<li>学会使用基本的 canvas api, 使用 canvas 可以完成简单的绘图</li>
<li>实现数据的可视化 </li>
</ol>
<h2 id="-">基本绘图</h2>
<h3 id="-">基本绘图方法</h3>
<p><strong>绘图步骤</strong></p>
<ol>
<li>获得 <code>canvas</code> 对象.</li>
<li>调用 <code>getContext</code> 方法, 提供字符串参数 <code>&#39;2d&#39;</code>.</li>
<li>该方法返回 <code>CanvasRenderingContext2D</code> 类型的对象. 该对象提供基本的绘图命令.</li>
<li>使用 <code>CanvasRenderingContext2D</code> 对象提供的方法进行绘图.</li>
<li>基本绘图命令<ul>
<li>设置开始绘图的位置: <code>context.moveTo( x, y )</code>.</li>
<li>设置直线到的位置: <code>context.lineTo( x, y )</code>.</li>
<li>描边绘制: <code>context.stroke()</code>.</li>
<li>填充绘制: <code>context.fill()</code>.</li>
<li>闭合路径: <code>context.closePath()</code>.</li>
</ul>
</li>
</ol>
<p><strong>01-绘制基本线</strong></p>
<pre><code>    var canvas = document.createElement( &#39;canvas&#39; );
    canvas.width = 500;
    canvas.height = 400;
    canvas.style.border = &#39;1px dashed red&#39;;
    document.body.appendChild( canvas );
    // 获得 CanvasRenderingContext2D 对象
    var context = canvas.getContext( &#39;2d&#39; );
    // 设置 起点
    context.moveTo( 0, 0 );
    // 绘制直线
    context.lineTo( 500, 400 );
    // 设置 起点
    context.moveTo( 0, 400 );
    // 绘制直线
    context.lineTo( 500, 0 );
    // 描边显示效果
    context.stroke();
</code></pre><p>运行结果为</p>
<p><img src="./imgs/2016-08-06_015256.png" alt=""></p>
<h4 id="-">计算机直角坐标系</h4>
<p><img src="./imgs/2016-08-06_025322.png" alt=""></p>
<h4 id="-">代码分析</h4>
<ol>
<li>需要绘图就需要有 <code>canvas</code> 标签, 该标签用于展示图像.</li>
<li><code>canvas</code> 的宽高不要使用 CSS 来设置, 会有拉伸的问题. 应该直接使用属性设置.</li>
<li>但是 <code>canvas</code> 只是展示图像的标签, 它没有绘图的能力. 需要使用 <code>canvas</code> 的上下文工具来实现绘图.</li>
<li>使用 <code>canvas.getContext( &#39;2d&#39; )</code> 可以获得绘图工具, 该工具是 <code>CanvasRenderingContext2D</code> 类型的对象.</li>
<li>需要绘图, 首选设置绘图的起点. <ul>
<li>使用 <code>canvas</code> 绘图, 需要主要的是他主张先描点, 再连线绘制效果.</li>
<li>因此需要首先设置起点, 然后在起点的基础上描述其他需要的点.</li>
<li>使用 <code>CanvasRenderingContext2D.moveTo( x, y )</code> 方法设置起点.<ul>
<li>其中 x, y 表示的是在坐标系中的位置.</li>
</ul>
</li>
</ul>
</li>
<li>使用 <code>CanvasRenderingContext2D.lineTo( x, y )</code> 来描述绘制直线的下一个点. 依次类推可以描述多个点.</li>
<li>描点结束后, 需要使用 <code>CanvasRenderingContext2D.stroke()</code> 方法来连线. 开可以显示出效果.</li>
</ol>
<h4 id="getcontext-">getContext 方法</h4>
<p>语法: <code>Canvas.getContext( typeStr )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于绘制上下文工具.</li>
<li>如果是绘制平面图形使用 <code>&#39;2d&#39;</code> 作为参数, 如果绘制立体图形使用 <code>&#39;webgl&#39;</code>.</li>
<li>使用 <code>&#39;2d&#39;</code> 返回 <code>CanvasRenderingContext2D</code> 类型的对象.</li>
<li>使用 <code>&#39;webgl&#39;</code> 返回 <code>WebGLRenderingContext</code> 类型的对象.</li>
</ol>
<h4 id="moveto-">moveTo 方法</h4>
<p>语法: <code>CanvasRenderingContext2D.moveTo( x, y )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于设置绘制起点.</li>
<li>其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.</li>
</ol>
<h4 id="lineto-">lineTo 方法</h4>
<p>语法: <code>CanvasRenderingContext2D.lineTo( x, y )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于设置需要绘制直线的另一个点. 最终描边后会连线当前点和方法参数描述的点.</li>
<li>其中参数 x, y 表示在坐标系中的位置, 分别是 x 坐标与 y 坐标.</li>
</ol>
<h4 id="stroke-">stroke 方法</h4>
<p>语法: <code>CanvasRenderingContext2D.stroke()</code></p>
<p>描述: 该方法用于连线, 将描述的所有点按照指定顺序连接起来.</p>
<h4 id="-">结论</h4>
<ol>
<li>绘图先要获得上下文, 即绘图工具</li>
<li>绘图需要设置开始的坐标</li>
<li>绘图是先描点, 然后一个一个依次连线</li>
<li>依次绘图只能绘制单一样式( 色彩等 )</li>
</ol>
<h3 id="-">直线图形</h3>
<p>分别绘制下面的案例:</p>
<p><img src="./imgs/2016-08-06_023133.png" alt=""></p>
<ol>
<li>绘制直线计算坐标.</li>
<li>描边调用 <code>CanvasRenderingContext2D.stroke()</code> 方法.</li>
<li>填充使用 <code>CanvasRenderingContext2D.fill()</code> 方法.</li>
</ol>
<h4 id="fill-">fill 方法</h4>
<p>语法: <code>CanvasRenderingContext2D.fill()</code></p>
<p>描述: 该方法会按照描绘的点的路径来填充图形. 默认是黑色.</p>
<h3 id="-">非零环绕原则</h3>
<p>绘制下面的图</p>
<p><img src="./imgs/2016-08-06_134021.png" alt=""></p>
<p>填充满足非零环绕数原则</p>
<p><img src="./imgs/20151227142627714" alt=""></p>
<p>说明:</p>
<ol>
<li>在 <code>canvas</code> 中使用各种方法描点实际上描述的是一个称为路径( path )的东西.</li>
<li>在 <code>canvas</code> 绘图中, 所有描述的东西都是路径, 只有最后填充或描边的时候才会显示出效果.</li>
<li>每一个路径都是一个状态.</li>
</ol>
<p>练习: 绘制下面图形</p>
<p><img src="./imgs/2016-08-06_135624.png" alt=""></p>
<h3 id="-">闭合路径</h3>
<h4 id="closepath-">closePath 方法</h4>
<p>语法: <code>CanvasRenderingContext2D.closePath()</code></p>
<p>描述: 使用该方法可以将最后一个描点与最开始的描点自动连接起来.</p>
<p><strong>案例</strong></p>
<pre><code>    ...
    ctx.moveTo( 100, 100 );
    ctx.lineTo( 300, 100 );
    ctx.lineTo( 300, 200 );
    ctx.closePath();
    ctx.stroke();
</code></pre><p>结果为:</p>
<p><img src="./imgs/2016-08-06_140228.png" alt=""></p>
<p>练习: 使用 <code>closePath</code> 改写非零环绕的案例.</p>
<h3 id="-">路径的概念</h3>
<ol>
<li>路径就是一次绘图<ul>
<li>类比使用油漆刷墙面</li>
<li>首先打底色, 绝对不会一次性使用多个色彩</li>
<li>一定是先画完某一个色彩再考虑另一个色彩</li>
<li>除非需要自己创作才会考虑墙面绘画</li>
</ul>
</li>
<li>路径就好比一桶油漆和一把刷子, 一次性描点绘制. 如果重新更换油漆, 那么是绘制另一个区域.</li>
<li>如果需要开启新的绘制, 那么使用 <code>CanvasRenderingContext2D.beginPath()</code> 方法.</li>
</ol>
<p><strong>墙面油漆图示</strong></p>
<p><img src="./imgs/65-141105115211111.jpg" alt=""></p>
<p><img src="./imgs/123.jpg" alt=""></p>
<p><strong>示例</strong></p>
<p>如果需要在一个区域内绘制描边的图形和填充的图形. 例如</p>
<p><img src="./imgs/2016-08-08_124829.png" alt=""></p>
<h3 id="-">线型相关属性</h3>
<p>设置描边与填充不一定只能使用黑色的细线. 可以利用一些属性设置其效果</p>
<ol>
<li><code>CanvasRenderingContext2D.lineWidth</code> 设置线宽.</li>
<li><code>CanvasRenderingContext2D.lineCap</code> 设置线末端类型.</li>
<li><code>CanvasRenderingContext2D.lineJoin</code> 设置相交线的拐点.</li>
<li><code>CanvasRenderingContext2D.getLineDash()</code> 获得线段样式数组.</li>
<li><code>CanvasRenderingContext2D.setLineDash()</code> 设置线段样式.</li>
<li><code>CanvasRenderingContext2D.lineDashOffset</code> 绘制线段偏移量.</li>
</ol>
<h4 id="-">设置线宽</h4>
<p>语法: <code>CanvasRenderingContext2D.lineWidth = number</code></p>
<p>描述: 设置线宽.</p>
<p><strong>案例</strong></p>
<pre><code>    ...
    ctx.moveTo( 100, 100 );
    ctx.lineTo( 300, 100 );
    ctx.stroke();

    ctx.beginPath();
    ctx.lineWidth = 10;
    ctx.moveTo( 100, 250 );
    ctx.lineTo( 300, 250 );
    ctx.stroke();
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-08_130548.png" alt=""></p>
<h4 id="-">设置线末端类型</h4>
<p>语法: <code>CanvasRenderingContext2D.lineCap = value</code></p>
<p>描述: </p>
<ol>
<li>设置线型末端的样式, 可取值为: &#39;butt&#39;( 默认 ), &#39;round&#39;, &#39;square&#39;.</li>
<li>&#39;butt&#39; 表示两端使用方形结束.</li>
<li>&#39;round&#39; 表示两端使用圆角结束.</li>
<li>&#39;square&#39; 表示突出的圆角结束.</li>
</ol>
<p><strong>案例</strong></p>
<pre><code>    ...
    ctx.lineWidth = 10;
    ctx.moveTo( 100, 100 );
    ctx.lineTo( 300, 100 );
    ctx.stroke();

    ctx.beginPath();
    ctx.lineCap =  &#39;round&#39;;
    ctx.moveTo( 100, 130 );
    ctx.lineTo( 300, 130 );
    ctx.stroke();

    ctx.beginPath();
    ctx.lineCap =  &#39;square&#39;;
    ctx.moveTo( 100, 160 );
    ctx.lineTo( 300, 160 );
    ctx.stroke();
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-08_131353.png" alt=""></p>
<h4 id="-">设置相交线的拐点</h4>
<p>语法: <code>CanvasRenderingContext2D.lineJoin = value</code></p>
<p>描述:</p>
<ol>
<li>设置两条直线的拐点描述方式. 可以取值 &#39;round&#39;, &#39;bevel&#39;, &#39;miter&#39;(默认)</li>
<li>&#39;round&#39; 使用圆角连接.</li>
<li>&#39;bevel&#39; 使用平切连接.</li>
<li>&#39;miter&#39; 使用直角转.</li>
</ol>
<p><strong>案例</strong></p>
<pre><code>    ...
    ctx.lineWidth = 10;
    ctx.lineJoin = &#39;round&#39;;
    ctx.moveTo( 100, 100 );
    ctx.lineTo( 200, 200 );
    ctx.lineTo( 300, 100 );
    ctx.stroke();

    ctx.beginPath();
    ctx.lineJoin = &#39;bevel&#39;;
    ctx.moveTo( 100, 150 );
    ctx.lineTo( 200, 250 );
    ctx.lineTo( 300, 150 );
    ctx.stroke();

    ctx.beginPath();
    ctx.lineJoin = &#39;miter&#39;;
    ctx.moveTo( 100, 200 );
    ctx.lineTo( 200, 300 );
    ctx.lineTo( 300, 200 );
    ctx.stroke();
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-08_132309.png" alt=""></p>
<h4 id="-">虚线</h4>
<p>语法:</p>
<ol>
<li><code>CanvasRenderingContext2D.lineDashOffset = number</code> </li>
<li><code>CanvasRenderingContext2D.getLineDash()</code></li>
<li><code>CanvasRenderingContext2D.setLineDash()</code></li>
</ol>
<p>描述:</p>
<ol>
<li>setLineDash 用于设置开始绘制虚线的偏移量. 数字的正负表示左右偏移.</li>
<li>getLineDash() 与 setLineDash() 方法使用数组描述实线与虚线的长度.</li>
</ol>
<p><strong>演示</strong></p>
<pre><code>    ...
    ctx.moveTo( 100, 90 );
    ctx.lineTo( 100, 110 );
    ctx.moveTo( 300, 90 );
    ctx.lineTo( 300, 110 );

    ctx.moveTo( 100, 140 );
    ctx.lineTo( 100, 160 );
    ctx.moveTo( 300, 140 );
    ctx.lineTo( 300, 160 );

    ctx.moveTo( 100, 190 );
    ctx.lineTo( 100, 210 );
    ctx.moveTo( 300, 190 );
    ctx.lineTo( 300, 210 );
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo( 100, 100 );
    ctx.lineTo( 300, 100 );
    ctx.stroke();

    ctx.beginPath();
    ctx.setLineDash( [ 5, 5 ] );
    ctx.moveTo( 100, 150 );
    ctx.lineTo( 300, 150 );
    ctx.stroke();

    ctx.beginPath();
    ctx.lineDashOffset = -2;
    ctx.moveTo( 100, 200 );
    ctx.lineTo( 300, 200 );
    ctx.stroke();
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-08_134700.png" alt=""></p>
<h4 id="-">填充与描边样式</h4>
<p>语法:</p>
<ol>
<li><code>CanvasRenderingContext2D.strokeStyle = value</code></li>
<li><code>CanvasRenderingContext2D.fillStyle = value</code></li>
</ol>
<p>描述:</p>
<ol>
<li>strokeStyle 可以设置描边颜色, 与 CSS 的语法一样</li>
<li>fillStyle 设置填充颜色, 与 CSS 语法一样</li>
<li>这两个属性还可以设置渐变对象.</li>
</ol>
<p><strong>案例</strong></p>
<pre><code>    for (var i=0;i&lt;6;i++){
        for (var j=0;j&lt;6;j++){
            ctx.strokeStyle = &#39;rgb(0,&#39; + Math.floor(255-42.5*i) + &#39;,&#39; + 
                            Math.floor(255-42.5*j) + &#39;)&#39;;
            ctx.beginPath();
            ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true);
            ctx.stroke();
        }
    }
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-08_135332.png" alt=""></p>
<h2 id="-">实例练习</h2>
<h3 id="-">绘制坐标网格</h3>
<p>绘制下面的效果</p>
<p><img src="./imgs/2016-08-09_121247.png" alt=""></p>
<h3 id="-">绘制坐标系</h3>
<p>绘制下面的效果</p>
<p><img src="./imgs/2016-08-09_122426.png" alt=""></p>
<h3 id="-">绘制坐标点</h3>
<p>绘制下面的效果</p>
<p><img src="./imgs/2016-08-09_130716.png" alt=""></p>
<h3 id="-">绘制折线图</h3>
<p><img src="./imgs/2016-08-09_132957.png" alt=""></p>
<h1 id="-">中级篇</h1>
<h2 id="-">绘制形状</h2>
<p>绘制图形不仅仅是利用线条来实现绘图, 还可以有快捷的绘制图形的办法</p>
<ol>
<li>绘制矩形</li>
<li>绘制圆弧</li>
</ol>
<h3 id="-">绘制矩形</h3>
<p>绘制矩形的方法</p>
<ol>
<li><code>CanvasRenderingContext2D.strokeRect</code></li>
<li><code>CanvasRenderingContext2D.fillRect</code></li>
<li><code>CanvasRenderingContext2D.rect</code></li>
</ol>
<p>注意: <code>rect</code> 方法就是矩形路径, 还需要使用 <code>fill</code> 或 <code>stroke</code> 才可以看到效果. 
因此一般使用 <code>strokeRect</code> 或 <code>fillRect</code> 直接可以看到结果.</p>
<p>清除矩形区域</p>
<ol>
<li><code>CanvasRenderingContext2D.clearRect</code></li>
</ol>
<h4 id="-">绘制矩形框</h4>
<p>语法: <code>CanvasRenderingContext2D.strokeRect( x, y, width. height )</code></p>
<p>描述:</p>
<ol>
<li>用来绘制一个矩形. 比起直接使用 <code>moveTo</code> 和 <code>lineTo</code> 方法要简单许多.</li>
<li>该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.</li>
<li>使用该方法不需要使用 <code>moveTo</code> 方法设置起始点, 也不需要调用 <code>stroke</code> 等绘画方法. </li>
<li>绘制的矩形支持 <code>strokeStyle</code> 设置颜色样式.</li>
</ol>
<p><strong>案例</strong></p>
<pre><code>    ...
    ctx.strokeStyle = &#39;red&#39;;
    ctx.strokeRect( 100, 100, 200, 100 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-09_233542.png" alt=""></p>
<h4 id="-">绘制填充矩形</h4>
<p>语法: <code>CanvasRenderingContext2D.fillRect( x, y, width. height )</code></p>
<p>描述:</p>
<ol>
<li>用来绘制一个矩形. 比起直接使用 <code>moveTo</code> 和 <code>lineTo</code> 方法要简单许多.</li>
<li>该方法的前两个参数表示绘制矩形的左上角的坐标. 后两个参数表示这个矩形的宽高.</li>
<li>使用该方法不需要使用 <code>moveTo</code> 方法设置起始点, 也不需要调用 <code>stroke</code> 等绘画方法. </li>
<li>绘制的矩形支持 <code>fillStyle</code> 设置颜色样式.</li>
</ol>
<p><strong>案例</strong></p>
<pre><code>    ...
    ctx.fillStyle = &#39;green&#39;;
    ctx.fillRect( 100, 100, 200, 100 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-09_233846.png" alt=""></p>
<h4 id="-">清除矩形区域</h4>
<p>语法: <code>CanvasRenderingContext2D.clearRect( x, y, width, height )</code></p>
<p>描述:</p>
<ol>
<li>用于清除画布中的矩形区域的内容.</li>
<li>参数 x, y 表示矩形区域左上角的坐标, width 与 height 表示矩形区域的宽高.</li>
</ol>
<p><strong>案例</strong></p>
<pre><code>    ...
    ctx.fillRect( 100, 100, 200, 100 );
    ctx.clearRect( 110, 110, 50, 50 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_001845.png" alt=""></p>
<h4 id="-">案例</h4>
<p>利用绘制图形与清除矩形区域, 可以实现简单的动画. 例如代码: </p>
<pre><code>    ...
    var x = 10, y = 10, oldx = 10, oldy = 10;
    var width = 100, height = 50;     
    var intervalId = setInterval(function () {
        ctx.clearRect( oldx - 1, oldy - 1, width + 2, height + 2 );

        ctx.strokeRect( x, y, width, height );

        oldx = x;
        oldy = y;

        x += 4;
        y += 2;

        if ( oldy &gt;= 200 ) {
            // clearInterval( intervalId );
            x = 10, y = 10;
        }
    }, 20);
</code></pre><p><strong>简单效果</strong></p>
<p><img src="./imgs/2016-08-10_003757.gif" alt=""></p>
<p>有时为了简单常常将整个画布都清除, 这样就不用每次计算清除的问题.</p>
<pre><code>    ctx.clearRect( 0, 0, cas.width, cas.height );
    // 也可以设置画布宽度, 这样就会自动清除
    cas.width = cas.width;
</code></pre><h3 id="-">绘制圆弧</h3>
<p>绘制圆弧的方法有</p>
<ol>
<li><code>CanvasRenderingContext2D.arc()</code></li>
<li><code>CanvasRenderingContext2D.arcTo()</code></li>
</ol>
<h4 id="-">绘制圆弧</h4>
<p>语法: <code>CanvasRenderingContext2D.arc( x, y, radius. startAngle. endAngle, anticlockwise )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于绘制一段弧, 配合开始点的位置 与 <code>stroke</code> 方法或 <code>fill</code> 方法可以绘制扇形.</li>
<li>方法中的前两个参数 x, y 表示绘制圆弧的圆心坐标.</li>
<li>参数 radius 表示圆弧半径, 单位为弧度.</li>
<li>参数 startAngle 与 endAngle 表示开始到结束的角度. 角度以水平向右为 0 弧度, 顺时针为正方向.</li>
<li>参数 anticlockwise 表示是否采用默认的正向角度, 如果传入 true 表示逆指针为正. 该参数可选.</li>
</ol>
<p><strong>案例</strong></p>
<pre><code>    // 在 200, 200 的地方绘制一段半径为 100 的圆弧, 圆心角为 - PI / 2 到 PI / 4
    ...
    ctx.arc( 200, 200, 100, -Math.PI/2, Math.PI/4 );
    ctx.stroke();

    // 为了方便看清楚结构, 绘制坐标轴
    ctx.beginPath();
    ctx.strokeStyle = &#39;red&#39;;
    ctx.moveTo( 50, 200 );
    ctx.lineTo( 350, 200 );

    ctx.moveTo( 200, 50 );
    ctx.lineTo( 200, 350 );

    ctx.moveTo( 200, 200 );
    ctx.lineTo( 300, 300 );

    ctx.stroke();
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_011024.png" alt=""></p>
<h5 id="-">注意事项</h5>
<ol>
<li>使用 arc 绘图的时候, 如果没有设置 <code>moveTo</code> 那么会从开始的绘弧的地方作为起始点. 如果设置了 <code>moveTo</code>, 那么会连线该点与圆弧的起点.</li>
<li>如果使用 <code>stroke</code> 方法, 那么会从开始连线到圆弧的起始位置. 如果是 <code>fill</code> 方法, 会自动闭合路径填充.</li>
</ol>
<p><strong>例如</strong></p>
<p><img src="./imgs/2016-08-10_012936.png" alt=""></p>
<h4 id="-">绘制扇形</h4>
<p>绘制扇形的重点是需要设置起始位置为圆心点, 然后闭合路径即可</p>
<pre><code>    ...
    ctx.strokeStyle = &#39;red&#39;;
    ctx.fillStyle = &#39;pink&#39;;

    ctx.moveTo( 100, 200 );
    ctx.arc( 100, 200, 100, -Math.PI/3, Math.PI/3 );
    ctx.closePath();
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo( 300, 200 );
    ctx.arc( 300, 200, 100, -Math.PI/3, Math.PI/3 );
    ctx.closePath();
    ctx.fill();
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_013523.png" alt=""></p>
<h4 id="-">绘制扇形动画</h4>
<p>绘制扇形动画, 就是每隔几毫秒( 20 毫秒)擦除以前绘制的内容, 然后在以前绘制的基础上比以前多绘制一点东西.
这里多绘制的内容就是由角度决定. 比如一开始角度从 <code>-Math.PI / 2</code> 开始绘制. 那么每次角度都 <code>+0.1</code>, 
直到 绘制到 <code>Math.PI * 3 / 2</code> 为止.</p>
<pre><code>    ...
    ctx.fillStyle = &#39;green&#39;;
    var startAngle = -Math.PI / 2,
        angle = startAngle,
        x = 200, y = 200,
        r = 100;
    var intervalId = setInterval(function () {
        // 清除之前绘制的内容
        ctx.clearRect( 0, 0, cas.width, cas.height );
        // 角度增量
        angle += 0.1;
        // 判断是否停止计时器
        if ( angle &gt;= Math.PI * 3 / 2 ) {
            clearInterval( intervalId);
            angle = Math.PI * 3 / 2; 
            console.log( &#39;绘制完成&#39; );
        }
        // 绘制
        ctx.moveTo( x, y );
        ctx.arc( x, y, r, startAngle, angle );
        ctx.fill();
    }, 20);
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/123.gif" alt=""></p>
<h4 id="-">绘制饼形图</h4>
<p>绘制饼形图最大的特点是角度是叠加的. 开始从 <code>-Math.PI/2</code> 开始绘制, 达到执行角 <code>x</code> 后, 下一个区域从 <code>x</code> 开始绘制,
然后有到一个角 <code>y</code> 停下来. 如此反复到 <code>Math.PI * 3 / 2</code> 结束.</p>
<p>本节看两个案例, 一个固定等分, 一个由数据源来定义角度.</p>
<h5 id="-">三等分饼形图</h5>
<p>绘制一个三等分的饼形图, 颜色使用 红, 绿, 蓝.</p>
<pre><code>    var x = 200, y = 200,
        r = 100,
        step = Math.PI * 2 / 3,     // 120 度一个区域
        start = -Math.PI / 2,       // 起始角度
        colors = [ &#39;red&#39;, &#39;green&#39;, &#39;blue&#39; ];

    for ( var i = 0; i &lt; 3; i++ ) {
        ctx.beginPath();
        ctx.moveTo( x, y );
        ctx.fillStyle = colors[ i ];
        ctx.arc( x, y, r, start, start+=step );
        ctx.fill();
    }
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_021710.png" alt=""></p>
<h5 id="-">根据数据定义角度</h5>
<p>根据数据源定义角度, 就是将所有的数据求和, 按照总和为 <code>2 * Math.PI</code> 的结论计算出每一个数据部分的弧度值.
同时颜色可以提前定义好.</p>
<p>从 Konva 库中分离出来的颜色</p>
<pre><code>    var colors = 
        ( &quot;aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,&quot; +
        &quot;blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,&quot; +
        &quot;crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,&quot; +
        &quot;darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,&quot; +
        &quot;darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,&quot; +
        &quot;floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,&quot; +
        &quot;honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,&quot; + 
        &quot;lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,&quot; +
        &quot;lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,&quot; +
        &quot;lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,&quot; +
        &quot;mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,&quot; +
        &quot;mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,&quot; +
        &quot;palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,&quot; +
        &quot;purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,&quot; +
        &quot;silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,transparent,&quot; +
        &quot;tomato,turquoise,violet,wheat,white,whitesmoke,yellow,yellowgreen&quot; ).split( &#39;,&#39; );
</code></pre><!--
    Konva 库中的颜色值, 使用 rgb( r, g, b ) 方法得到颜色

    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 132, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 255, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 203],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [119, 128, 144],
    slategrey: [119, 128, 144],
    snow: [255, 255, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    transparent: [255, 255, 255, 0],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 5]


-->
<p>如果得到数据</p>
<pre><code>    var data = [ 123, 156, 47, 100, 80 ];
</code></pre><p>那么计算各个部分的比例时, 可以构造一个存储分量值与弧度的对象数组.</p>
<pre><code>    var sum = 0;
    for ( var i = 0; i &lt; data.length; i++ ) {
        sum += data[ i ];
    }
    // 得到总数后, 分量比就有了
    var odata = data.map(function ( v, i ) {
        return { value: v, radius: v * 2 * Math.PI / sum };
    });
</code></pre><p>最后根据数据开始绘图</p>
<pre><code>    // 开始绘图
    var start = -Math.PI / 2,
        x = 200, y = 200,
        r = 100;

    for ( var i = 0; i &lt; odata.length; i++ ) {
        ctx.beginPath();
        ctx.fillStyle = colors[ i + 10 ];
        ctx.moveTo( x, y );
        ctx.arc( x, y, r, start, start+=odata[ i ][ &#39;radius&#39; ] );
        ctx.fill();
    }
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_024116.png" alt=""></p>
<h4 id="-">绘制相切弧</h4>
<p>语法: <code>CanvasRenderingContext2D.arcTo( x1, y1, x2, y2, radius )</code></p>
<p>描述:</p>
<ol>
<li>该方法用于绘制圆弧</li>
<li>绘制的规则是当前位置与第一个参考点连线, 绘制的弧与该直线相切.</li>
<li>同时连接两个参考点, 圆弧根据半径与该连线相切</li>
</ol>
<p>例如有一个起始点 <code>( 100, 100 )</code>, 那么绘制其点. 颜色设置为红色.</p>
<pre><code>    ctx.fillStyle = &#39;red&#39;;
    ctx.fillRect( 100 - 4, 100 - 4, 8, 8 );
</code></pre><p>然后两个参考点分别为 <code>( 100, 300 )</code> 和 <code>( 300, 300 )</code>, 绘制出该点</p>
<pre><code>    ctx.fillRect( 100 - 4, 300 - 4, 8, 8 );
    ctx.fillRect( 300 - 4, 300 - 4, 8, 8 );
</code></pre><p>连接两个参考点</p>
<pre><code>    ctx.beginPath();
    ctx.strokeStyle = &#39;red&#39;;
    ctx.moveTo( 100, 300 );
    ctx.lineTo( 300, 300 );
    ctx.stroke();
</code></pre><p>得到效果为</p>
<p><img src="./imgs/2016-08-10_030033.png" alt=""></p>
<p>调用 <code>arcTo</code> 方法绘制圆弧. 记得将起始点设置为 <code>( 100, 100 )</code></p>
<pre><code>    ctx.beginPath();
    ctx.strokeStyle = &#39;blue&#39;;
    ctx.moveTo( 100, 100 );

    ctx.arcTo( 100, 300, 300, 300, 100 );
    ctx.stroke();
</code></pre><p>得到效果</p>
<p><img src="./imgs/2016-08-10_030327.png" alt=""></p>
<p>注意: 使用该方法可以使用圆弧连接两条直线, 而不用计算复杂的起始角度与结束角度. 因此用于绘制圆角矩形等案例较多.</p>
<h4 id="-">绘制圆角矩形</h4>
<p>封装一个函数, 用于绘制圆角矩形. </p>
<ol>
<li>参考 <code>rect</code> 方法, 需要坐标参数 x, y.</li>
<li>由于设置圆角, 因此需要设置圆角半径 cornerRadius.</li>
<li>还需要提供宽高.</li>
</ol>
<p>首先绘制一个矩形边框. 但是需要考虑圆角, 虽然从 x, y 开始绘制, 但是中间要空出 半径的距离.</p>
<pre><code>    var x = 100, y = 100, width = 300, height = 100,
        cornerRadius = 10;
    ctx.strokeStyle = &#39;red&#39;;

    ctx.moveTo( x + cornerRadius, y );
    ctx.lineTo( x + width - cornerRadius, y );

    ctx.moveTo( x + width, y + cornerRadius );
    ctx.lineTo( x + width, y + height - cornerRadius );

    ctx.moveTo( x + width - cornerRadius, y + height );
    ctx.lineTo( x + cornerRadius, y + height );

    ctx.moveTo( x, y + height - cornerRadius );
    ctx.lineTo( x, y + cornerRadius );

    ctx.stroke();
</code></pre><p>效果为</p>
<p><img src="./imgs/2016-08-10_031610.png" alt=""></p>
<p>然后再分别绘制四个角, 设置当前位置与参考点的位置. 设置当前位置为一个线端点, 然后参考点依次就是 矩形顶点 和 另一个线段的端点.</p>
<pre><code>    ctx.moveTo( x + cornerRadius, y );
    ctx.arcTo( x, y, x, y + cornerRadius, cornerRadius );
</code></pre><p>即可得到</p>
<p><img src="./imgs/2016-08-10_032430.png" alt=""></p>
<p>同理绘制另外三个圆角</p>
<pre><code>    ctx.moveTo( x + width - cornerRadius, y );
    ctx.arcTo( x + width, y, x + width, y + cornerRadius, cornerRadius );

    ctx.moveTo( x + width, y + height - cornerRadius );
    ctx.arcTo( x + width, y + height, x + width - cornerRadius, y + height, cornerRadius );

    ctx.moveTo( x + cornerRadius, y + height );
    ctx.arcTo( x, y + height, x, y + height - cornerRadius, cornerRadius );
</code></pre><p>即可得到</p>
<p><img src="./imgs/2016-08-10_032852.png" alt=""></p>
<p>封装成方法就可以绘制更多圆角矩形了. 封装中注意 <code>beginPath()</code> 和 <code>save()</code> 和 <code>restore()</code></p>
<pre><code>    function cRect ( x, y, width, height, cornerRadius, color ) {
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = color || &#39;red&#39;;

        ctx.moveTo( x + cornerRadius, y );
        ctx.lineTo( x + width - cornerRadius, y );

        ctx.moveTo( x + width, y + cornerRadius );
        ctx.lineTo( x + width, y + height - cornerRadius );

        ctx.moveTo( x + width - cornerRadius, y + height );
        ctx.lineTo( x + cornerRadius, y + height );

        ctx.moveTo( x, y + height - cornerRadius );
        ctx.lineTo( x, y + cornerRadius );


        // 开始绘制四个圆角
        ctx.moveTo( x + cornerRadius, y );
        ctx.arcTo( x, y, x, y + cornerRadius, cornerRadius );

        ctx.moveTo( x + width - cornerRadius, y );
        ctx.arcTo( x + width, y, x + width, y + cornerRadius, cornerRadius );

        ctx.moveTo( x + width, y + height - cornerRadius );
        ctx.arcTo( x + width, y + height, x + width - cornerRadius, y + height, cornerRadius );

        ctx.moveTo( x + cornerRadius, y + height );
        ctx.arcTo( x, y + height, x, y + height - cornerRadius, cornerRadius );

        ctx.stroke();
        ctx.restore();
    }
</code></pre><p>调用代码</p>
<pre><code>    cRect( 50, 50, 100, 50, 5 );
    cRect( 100, 120, 100, 80, 8, &#39;blue&#39; );
    cRect( 300, 100, 200, 100, 10, &#39;green&#39; );
</code></pre><p>得到结果为</p>
<p><img src="./imgs/2016-08-10_033552.png" alt=""></p>
<h2 id="-">绘制文本</h2>
<p>绘制文本的方法</p>
<ol>
<li><code>CanvasRenderingContext2D.fillText()</code></li>
<li><code>CanvasRenderingContext2D.strokeText()</code></li>
<li><code>CanvasRenderingContext2D.measureText()</code></li>
</ol>
<p>文本样式</p>
<ol>
<li><code>CanvasRenderingContext2D.font</code></li>
<li><code>CanvasRenderingContext2D.textAlign</code></li>
<li><code>CanvasRenderingContext2D.textBaseline</code></li>
</ol>
<h3 id="-">绘制文字</h3>
<p>语法:</p>
<ol>
<li><code>CanvasRenderingContext2D.strokeText( text, x, y[, maxWidth] )</code></li>
<li><code>CanvasRenderingContext2D.fillText( text, x, y[, maxWidth] )</code></li>
</ol>
<p>描述:</p>
<ol>
<li>这两个方法的功能都是在给定的 x, y 坐标下绘制文本内容.</li>
<li>stroke 绘制描边文字, 文字内空心. fill 绘制填充文字, 即实心文字.</li>
<li>最后一个参数可选, 用于限制文字的总宽. 特殊条件下, 系统会自动调整文字宽度与大小以适应该参数限制.</li>
</ol>
<p><strong>案例</strong></p>
<pre><code>    ...
    ctx.strokeRect( 100, 100, 200, 50 );
    ctx.strokeText( &#39;Hello JK&#39;, 100, 100 );

    ctx.strokeRect( 100, 200, 200, 50 );
    ctx.fillText( &#39;Hello JK&#39;, 100, 200 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_091333.png" alt=""></p>
<p>注意: 第一个文字由于中间空心, 所以文字相当于双线显示. 就显得较粗.</p>
<p>根据绘制的矩形块可以发现文字几乎使用该点作为文字基线参考.</p>
<h3 id="-">计算文本尺寸</h3>
<p>语法: <code>CanvasRenderingContext2D.measureText()</code></p>
<p>描述:</p>
<ol>
<li>该方法返回一个文本尺寸对象, TextMetrics 对象.</li>
<li>TextMetrics 对象属性很多, 常用的 width 属性可以获取文字的宽度.</li>
</ol>
<h3 id="-">设置文字属性</h3>
<h4 id="-">设置文字字体</h4>
<p>语法: <code>CanvasRenderingContext2D.font = value</code></p>
<p>描述:</p>
<ol>
<li>该属性用于设置绘制字体的各种信息, 与 CSS 语法一致, 设置字体形状, 样式, 字号粗细等.</li>
<li>其顺序可以是: style | variant | weight | size/line-height | family.</li>
<li>默认值为 10px sans-serif</li>
</ol>
<p>修改字号后查看 strokeText 与 fillText 的区别</p>
<pre><code>    ...
    ctx.font = &#39;50px 黑体&#39;;
    ctx.strokeRect( 100, 100, 200, 50 );
    ctx.strokeText( &#39;Hello JK&#39;, 100, 100 );

    ctx.strokeRect( 100, 200, 200, 50 );
    ctx.fillText( &#39;Hello JK&#39;, 100, 200 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_105346.png" alt=""></p>
<h4 id="-">设置字体水平对齐方式</h4>
<p>语法: <code>CanvasRenderingContext2D.textAlign = value</code></p>
<p>描述:</p>
<ol>
<li>该属性用于设置文字的水平对齐方式. 设置文字居中, 靠左右对齐等.</li>
<li>该属性可以设置的值有: start( 默认 ), end, left, right, center.</li>
</ol>
<p>start 表示根据参考基准点的垂直直线左靠对齐</p>
<pre><code>    ...
    ctx.moveTo( 150, 100 );
    ctx.lineTo( 150, 200 );
    ctx.moveTo( 100, 150 );
    ctx.lineTo( 200, 150 );
    ctx.strokeStyle = &#39;red&#39;;
    ctx.stroke();

    ctx.font = &#39;30px 黑体&#39;;
    ctx.textAlign = &#39;start&#39;; // 默认
    ctx.fillText( &#39;测试文字&#39;, 150, 150 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_104221.png" alt=""></p>
<p>end 表示根据参考基准点的垂直直线右靠对齐</p>
<pre><code>    ...
    ctx.font = &#39;30px 黑体&#39;;
    ctx.textAlign = &#39;end&#39;;
    ctx.fillText( &#39;测试文字&#39;, 150, 150 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_104403.png" alt=""></p>
<p>left 与 right 就是左对齐与右对齐的意思</p>
<pre><code>    ...
    ctx.font = &#39;30px 黑体&#39;;
    ctx.textAlign = &#39;left&#39;;
    ctx.fillText( &#39;left&#39;, 150, 150 );
    ctx.textAlign = &#39;right&#39;
    ctx.fillText( &#39;right&#39;, 150, 150 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_104802.png" alt=""></p>
<p>最后 center 就是居中的含义.</p>
<pre><code>    ctx.font = &#39;50px 黑体&#39;
    ctx.textAlign = &#39;center&#39;;
    ctx.fillText( &#39;00000&#39;, 150, 150 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_105718.png" alt=""></p>
<h4 id="-">设置字体垂直对齐方式</h4>
<p>语法: <code>CanvasRenderingContext2D.textBaseline = value</code></p>
<p>描述:</p>
<ol>
<li>该方法设置文字在垂直方向上的对齐方式. </li>
<li>该属性可以取值: top, middle, bottom, hanging, alphabetic, ideographic</li>
<li>基于参考点的直线, 其中 top, middle, buttom 分别表示靠上, 居中, 靠下对齐.</li>
<li>alphabetic 表示字母基线, 类似于英文字母的对齐方式. 例如 a, g, f 等字母.</li>
<li>ideographic 表意对齐. 使用字母对齐中超出的字母为参考. 即比字母基线略靠下.</li>
<li>所有的对齐方式是根据文字特点相关的. 对于中文主要使用的还是 top, bottom 和 middle.</li>
</ol>
<p>top, middle, bottom 使用的较多</p>
<pre><code>    ...
    // ------------------
    ctx.moveTo( 100, 80 );
    ctx.lineTo( 500, 80 );
    ctx.strokeStyle = &#39;red&#39;;
    ctx.stroke();

    ctx.font = &#39;30px 黑体&#39;;

    ctx.textBaseline = &#39;top&#39;;
    ctx.fillText( &#39;abfghijklpqrty&#39;, 150, 80 );

    // ------------------
    ctx.translate( 0, 100 );
    ctx.moveTo( 100, 80 );
    ctx.lineTo( 500, 80 );
    ctx.strokeStyle = &#39;red&#39;;
    ctx.stroke();

    ctx.font = &#39;30px 黑体&#39;;

    ctx.textBaseline = &#39;bottom&#39;;
    ctx.fillText( &#39;abfghijklpqrty&#39;, 150, 80 );

    // ------------------
    ctx.translate( 0, 100 );
    ctx.moveTo( 100, 80 );
    ctx.lineTo( 500, 80 );
    ctx.strokeStyle = &#39;red&#39;;
    ctx.stroke();

    ctx.font = &#39;30px 黑体&#39;;

    ctx.textBaseline = &#39;middle&#39;;
    ctx.fillText( &#39;abfghijklpqrty&#39;, 150, 80 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_111756.png" alt=""></p>
<p>alphabetic 表示字母参考线, ideographic 会比它低一点, hanging 表示悬挂.</p>
<pre><code>    ctx.moveTo( 100, 80 );
    ctx.lineTo( 500, 80 );
    ctx.strokeStyle = &#39;red&#39;;
    ctx.stroke();

    ctx.font = &#39;30px 黑体&#39;;

    ctx.textBaseline = &#39;alphabetic&#39;;
    ctx.fillText( &#39;abfghijklpqrty&#39;, 150, 80 ); 

    // -------------------------------------------------

    ctx.translate( 0, 100 );
    ctx.moveTo( 100, 80 );
    ctx.lineTo( 500, 80 );
    ctx.strokeStyle = &#39;red&#39;;
    ctx.stroke();

    ctx.font = &#39;30px 黑体&#39;;

    ctx.textBaseline = &#39;ideographic&#39;;
    ctx.fillText( &#39;abfghijklpqrty&#39;, 150, 80 ); 

    // -------------------------------------------------

    ctx.translate( 0, 100 );
    ctx.moveTo( 100, 80 );
    ctx.lineTo( 500, 80 );
    ctx.strokeStyle = &#39;red&#39;;
    ctx.stroke();

    ctx.font = &#39;30px 黑体&#39;;

    ctx.textBaseline = &#39;hanging&#39;;
    ctx.fillText( &#39;abfghijklpqrty&#39;, 150, 80 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_113004.png" alt=""></p>
<p>实际上大多数参考方式只有在特定语言中有作用, 而且与字体也有相对复杂的关系. 例如( 下图是有部分错误的 ):</p>
<p><img src="./imgs/textBaseline.gif" alt=""></p>
<h2 id="-">绘制图片</h2>
<p>绘制图像虽然只有一个 <code>drawImage</code> 函数, 但是该函数有多重参数形式.</p>
<ol>
<li><code>CanvasRenderingContext2D.drawImage( img, dx, dy )</code>.</li>
<li><code>CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight )</code>.</li>
<li><code>CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )</code>.</li>
</ol>
<h3 id="-">绘制简单图像</h3>
<p>语法: <code>CanvasRenderingContext2D.drawImage( img, dx, dy )</code></p>
<p>描述:</p>
<ol>
<li>使用三个参数, 允许在画布上的 任意位置 绘制图片.</li>
<li>参数 img 是指图片对象. 可以是 img 标签, 或者是 video 标签, 已经另一个 canvas 等.</li>
<li>需要注意的是如果直接添加 img 对象是不可以的, 需要等待其加载. </li>
</ol>
<p>准备一张网络图片, 绘制, 便于查看其加载过程.</p>
<pre><code>    // 随便从百度中搜索 &#39;美女头像&#39;, 记录一个链接地址
    var url = &#39;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg&#39;;
    // 创建 img 对象
    var img = new Image(); // 就是 img 标签
    // 设置 src 属性为 图片
    img.src = url;

    // 绘图
    ctx.drawImage( img, 100, 100 );
</code></pre><p>此时没有任何结果, 打开调试工具查看 Net Work</p>
<p><img src="./imgs/2016-08-10_215925.png" alt=""></p>
<p>因为加载图片需要时间, 因此将绘制的方法放在 onload 事件中.</p>
<pre><code>    // 随便从百度中搜索 &#39;美女头像&#39;, 记录一个链接地址
    var url = &#39;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3289155966,3850025949&amp;fm=116&amp;gp=0.jpg&#39;;
    // 创建 img 对象
    var img = new Image(); // 就是 img 标签
    // 设置 src 属性为 图片
    img.src = url;

    // 绘图
    img.onload = function () {
        ctx.drawImage( img, 100, 100 );
    };
</code></pre><p>修改后就可得到效果</p>
<p><img src="./imgs/2016-08-10_220644.png" alt=""></p>
<p>注意: 这里使用 <code>new Image()</code> 与 <code>document.createElement( &#39;img&#39; )</code> 是一样的.</p>
<h3 id="-">在指定区域内绘制图像</h3>
<p>当图片比较大的时候, 如果使用这样的方式绘图, 那么图片可能会完全覆盖画布. 例如:</p>
<p><img src="./imgs/2016-08-10_222122.png" alt=""></p>
<p>因此, 需要将其控制在一个矩形区域内绘制. </p>
<p>语法: <code>CanvasRenderingContext2D.drawImage( img, dx, dy, dWidth, dHeight )</code></p>
<p>描述:</p>
<ol>
<li>参数 dWidth, dHeight 表示绘制的矩形区域. 绘制的 dx, dy 坐标决定了开始.</li>
<li>该方法绘制的图像会在指定范围内被压缩显示.</li>
</ol>
<p>将上面的图绘制在 <code>100 * 100</code> 的范围内.</p>
<pre><code>    ...
    ctx.drawImage( img, 100, 100, 100, 100 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_222838.png" alt=""></p>
<p>如果希望正常显示, 需要固定一个宽度或者高度, 然后根据比例计算出另一个值. 这里假定高度是 100. 计算宽度后绘图.</p>
<pre><code>    ...
    var heigth = 100, width;
    img.onload = function () {
        width = img.width * height / img.height;
        ctx.drawImage( img, 100, 100, width, height );
    };
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_223421.png" alt=""></p>
<h3 id="-">绘制任意图像</h3>
<p>类似于 CSS 中处理按钮等小图标的技巧, 将很多的效果图集中在一张 png 格式的背景透明的图片中, 这样可以提高效率也便于维护.
那么 drawImage 同样支持该方式绘图. 在画布中的指定位子与指定区域内, 绘制图片中的某个矩形区.</p>
<p>语法: <code>CanvasRenderingContext2D.drawImage( img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight )</code></p>
<p>描述: 这里的带有 s 前缀的参数就是指图源的矩形区域.</p>
<p>例如将图片的 <code>( 100, 100, 300, 200 )</code> 处的内容绘制到页面的 <code>( 100, 100, 300, 200 )</code> 的位置.</p>
<pre><code>    &#39;&#39;&#39;
    ctx.drawImage( img, 100, 100, 300, 200,  100, 100, 300, 200 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_224454.png" alt=""></p>
<h2 id="-">绘制动画</h2>
<p>有了图片部分绘制的功能, 我们就可以尝试绘制动画了. 准备一张图片</p>
<p><img src="./imgs/士兵.png" alt=""></p>
<p>然后开始的时候绘制第一行的第一张图. 计算它的坐标与宽高</p>
<pre><code>    var img = new Image();
    img.src = &#39;./imgs士兵(1).png&#39;
    img.onload = function () {
        var width = img.width / 4;
        var height = img.heigth / 4;
        // 第一张图的顶点是 0, 0, 宽高是 width, height
    };
</code></pre><p>那么第一行的第二张图就是 <code>( 0, width, width, height )</code>, 第三张就是 <code>( 0, width * 2, width, height )</code>. 
因此第一行的第 <code>i</code> 张图就是</p>
<pre><code>    var x = 0;
    var y = width * ( i - 1 );
</code></pre><p>同理得到, 第 <code>j</code> 列的 <code>x</code> 坐标是 <code>height * ( j - 1 )</code></p>
<p>现在绘制第一张图</p>
<pre><code>    ...
    var img = new Image();
    img.src = &#39;./imgs/士兵(1).png&#39;
    img.onload = function () {
        var width = img.width / 4;
        var height = img.height / 4;

        ctx.drawImage( img, 0, 0, width, height, 100, 100, width, height ); 
    };
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-10_231312.png" alt="">;</p>
<p>现在要求, 每隔 200 毫秒就切换一张图片, 现在只考虑第一行的图片.</p>
<pre><code>    ...
    var img = new Image();
    img.src = &#39;./imgs/士兵(1).png&#39;
    img.onload = function () {
        var width = img.width / 4;
        var height = img.height / 4;

        var i = 0;
        setInterval(function () {
            ctx.clearRect( 0, 0, cas.width, cas.height );
            ctx.drawImage( img, width * (i++ % 4), 0, width, height, 100, 100, width, height );
        }, 200 );
    };
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/士兵1.gif" alt=""></p>
<p>那么扩展一下, 把四行都画出来</p>
<p><img src="./imgs/士兵2.gif" alt=""></p>
<h1 id="-">高级篇</h1>
<h2 id="-">变换</h2>
<p>Canvas 绘图中支持矩阵变换功能. 其中涉及的常用方法有</p>
<ol>
<li><code>CanvasRenderingContext2D.transform()</code></li>
<li><code>CanvasRenderingContext2D.scale()</code></li>
<li><code>CanvasRenderingContext2D.translate()</code></li>
<li><code>CanvasRenderingContext2D.rotate()</code></li>
<li><code>CanvasRenderingContext2D.setTransForm()</code></li>
</ol>
<p>还有一些方法, 暂时没有普及与确定. 因此这里的几个方法才是最常用的方法.</p>
<h3 id="-">什么是变换</h3>
<p>计算机图形学是建立在解析几何基础之上的. 也就是说所有绘制的图形都是基于坐标进行计算得到的. 
那么利用坐标系位置的调整, 同样的坐标可以得到不同的效果. 例如有一个点 A ( 10, 10 ). 
可以在坐标系中绘制出该点.</p>
<p><img src="./imgs/2016-08-12_005104.png" alt=""></p>
<p>如果调整坐标系. 比如将坐标系向右移动 10 个单位, 得到</p>
<p><img src="./imgs/2016-08-12_005920.png" alt=""></p>
<p>此时同样是 A 点, 坐标就变成了 ( 0, 10 ). 然后再把坐标系向上移动 10 个单位, 得到</p>
<p><img src="./imgs/2016-08-12_010818.png" alt=""></p>
<p>那么针对新坐标系, 这个点的坐标就是 ( 0, 0 ). 这个就是坐标变换. 通过移动坐标的位置, 
对坐标进行旋转, 以及对坐标轴数据的缩放, 从而使得原有点的坐标发生变化, 
或利用原有的坐标点绘制新的效果. </p>
<p>坐标变换有一套完整的数学公式. 利用矩阵可以很容易的表示坐标的所有变换.</p>
<p><img src="./imgs/2016-08-12_012845.png" alt=""></p>
<p>这里的 a, b, c, d, e, f 就刚好是 <code>transform</code> 函数的 参数.</p>
<ol>
<li>其中 a 有时又标记为 m11. 它表示水平缩放.</li>
<li>其中 b 有时又标记为 m12. 它表示水平倾斜.</li>
<li>其中 c 有时又标记为 m21. 它表示垂直倾斜.</li>
<li>其中 d 有时又标记为 m22. 它表示垂直缩放.</li>
<li>其中 e 有时又标记为 dx. 它表示水平移动.</li>
<li>其中 f 有时又标记为 dy. 它表示垂直移动.</li>
</ol>
<p><strong>演示</strong></p>
<pre><code>    ...
    ctx.transform( 1, 0, 0, 1, 0, 0 );
    ctx.fillRect( 0, 0, 100, 100 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-12_013849.png" alt=""></p>
<p>这里矩阵变换会比较复杂, 因此在使用中一般使用简单的, 平移, 旋转 和 缩放 的简单 api.</p>
<h3 id="-">平移变换</h3>
<p>平移变换就是将原有坐标轴进行平行移动, 那么坐标轴移动后就可以使用新坐标来绘制图形了. </p>
<p>语法: <code>CanvasRenderingContext2D.translate( x, y )</code></p>
<p>描述: </p>
<ol>
<li>该方法将坐标进行平移.</li>
<li>x 表示水平移动, 正数向右, 负数向左. </li>
<li>y 表示垂直移动, 正数向下, 负数向上.</li>
<li>变换可以重复调用, 变换是可以累加的.</li>
</ol>
<p>使用该变换, 常常用于绘制不同位置, 但是形状重复的图形.</p>
<p>注意: 变换也会被 &quot;继承&quot;, 开启新路径后依旧保留原先变换.</p>
<h3 id="-">旋转变换</h3>
<p>语法: <code>CanvasRenderingContext2D.rotate( radian )</code></p>
<p>描述:</p>
<ol>
<li>该方法将坐标轴进行旋转变换.</li>
<li>参数是弧度, 表示旋转的方式. 正数表示顺时针旋转, 负数表示逆时针旋转.</li>
</ol>
<p>该变换常常用于实现旋转动画等.</p>
<h3 id="-">缩放变换</h3>
<p>语法: <code>CanvasRenderingContext2D.scale( x, y )</code></p>
<p>描述:</p>
<ol>
<li>该方法实现水平与垂直的缩放.</li>
<li>参数 x 控制水平缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大.</li>
<li>参数 y 控制垂直缩放倍率. 传参 1 表示不作缩放, 传入大于 1 的数字表示扩大.</li>
</ol>
<p>该变换常常用于放大与缩小, 以及反转的效果.</p>
<h2 id="-">环境</h2>
<p>前面提到 Canvas 是含有状态的, 也就是说需要修改颜色, 直线样式, 绘图方式等效果时需要开启一个新的状态.
但是有时在绘制过程中需要修改状态, 同时绘制完当前状态后又需要回到之前的状态中继续绘制另外的形状. 
那么只有再将修改过的样式载更改回来. 如果在该状态中修改的属性较多, 那么每次在回到之前状态时就有很多的代码.</p>
<p>Canvas 中引入了状态的保持机制. 使用 <code>CanvasRenderingContext2D.save()</code> 方法可以保存当前状态. 
如果需要恢复到已经保存的状态, 只需要调用 <code>CanvasRenderingContext2D.restore()</code> 方法即可.</p>
<p>状态保持的机制是基于状态栈实现的. 也就是说 save 一次就存储一个状态. restore 一次就将刚刚存入的恢复. 
如果 save 两次, 就需要 restore 两次, 才可以恢复到最先的状态.</p>
<p>一般在封装绘图的时候都会采用开始绘制之前, save 一次, 然后 开启一个新路径, 然后绘制结束后 restore, 
然后再开启一个新路径. 这样保持当前状态不会对其他绘图代码构成影响.</p>
<h2 id="-">优化</h2>
<p>canvas 在绘制图片的时候, drawImage 方法还支持将一个 canvas 绘制到另一个 canvas 中. 
因此使用该功能, 可以在内存中完成复杂的绘图, 将绘制好的半成品再绘制到 canvas 中合成需要的效果.</p>
<h2 id="-">画布保存</h2>
<p>画布在绘制后实际上就是一张图片, 可以直接右键另存为. 同时也支持使用 js 代码将其保存为 base64 编码的字符串.</p>
<p>语法: <code>Canvas.ToDataURL( type, encoderOptions )</code></p>
<p>描述: </p>
<ol>
<li>该方法可以将画布转换成 base64 格式的数据</li>
<li>type 表示输出类型. 例如: image/png 或 image/jpeg 等</li>
<li>encoderOptions 表示图片输出质量, 其取值在 0 到 1 之间. 如果是 1, 表示无损压缩, 必须使用 image/jpeg 或 image/webp 才起作用</li>
</ol>
<pre><code>    ...
    &lt;img id=&quot;img&quot;/&gt;
    ...
    var img = document.getElementById( &#39;img&#39; );

    var cas = document.createElement( &#39;canvas&#39; );
    cas.width = 100, cas.height = 100;
    var ctx = cas.getContext( &#39;2d&#39; );
    ctx.fillStyle = &#39;pink&#39;;
    ctx.fillRect( 0, 0, 100, 100 );

    var data = cas.toDataURL( &#39;image/png&#39;, 1 );

    img.src = data;
</code></pre><h2 id="-">渐变和图案</h2>
<p>绘制图像有两个主要方法, 一个是描边, 一个是填充. 前面介绍过要设置其样式, 可以使用 <code>strokeStyle</code> 和 <code>fillStyle</code> 属性,
只需要给它们提供颜色就可以了. 但是不仅仅是颜色, 它还支持渐变和重复.</p>
<p>相关方法</p>
<ol>
<li><code>CanvasRenderingContext2D.createLinearGradient()</code></li>
<li><code>CanvasRenderingContext2D.createRadialGradient()</code></li>
<li><code>CanvasRenderingContext2D.createPattern()</code></li>
</ol>
<h3 id="-">线性渐变</h3>
<p>语法: <code>CanvasRenderingContext2D.createLinearGradient( x0, y0, x1, y1 )</code></p>
<p>描述:</p>
<ol>
<li>该方法返回一个 CanvasGradient 对象. 用于描述渐变的方式.</li>
<li>该方法有两个参数, 用于表示线型渐变的方向与位置.</li>
<li>使用的时候, 首先创建一个 CanvasGradient 对象, 然后利用 addColorStop 方法添加颜色区间.<ol>
<li>方法语法: <code>CanvasGradient.addColorStop( rate, color )</code>.</li>
<li>该方法用于设置在某个比例位置的颜色是什么. rate 的取值是 0 到 1 之间.</li>
<li>可以添加多个渐变点.</li>
</ol>
</li>
<li>然后将该对象赋值给 <code>*Style</code> 属性即可.</li>
</ol>
<p><strong>案例</strong></p>
<pre><code>    ...
    var canvasGradient = ctx.createLinearGradient( 0, 25, 200, 25 );
    canvasGradient.addColorStop( 0, &#39;blue&#39; );
    canvasGradient.addColorStop( 1, &#39;red&#39; );
    ctx.fillStyle = canvasGradient;

    ctx.fillRect( 0, 100, 200, 50 );
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-13_013233.png" alt=""></p>
<p>注意: 渐变点的坐标是基于坐标轴来计算的.</p>
<h3 id="-">放射渐变</h3>
<p>语法: <code>CanvasRenderingContext2D.createRadialGradient( x0, y0, r0, x1, y1, r1 )</code></p>
<p>描述:</p>
<ol>
<li>该方法实现放射渐变, 渐变的是在两个圆之间. 一般会使用两个内含关系的圆.</li>
<li>前三个参数分别表示其中一个圆的圆心的坐标, 以及半径.</li>
<li>后三个参数分别表示另一个圆的圆心的坐标, 以及半径.</li>
<li>绘制渐变效果用法与线性渐变一样.</li>
</ol>
<p><strong>案例</strong> </p>
<pre><code>    var x = cas.width / 2, y = cas.height / 2, r = 100;
    var g = ctx.createRadialGradient( x + r * 2 / 3, y - r * 2 / 3, 0, x + r / 3, y - r / 3, r * 4 / 3 );
    g.addColorStop( 0, &#39;#fff&#39; );
    g.addColorStop( 1, &#39;#f00&#39; );
    ctx.fillStyle = g;
    ctx.arc( x, y, r, 0, 2 * Math.PI );
    ctx.fill();
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-13_014617.png" alt=""></p>
<h3 id="-">重复填充</h3>
<p>语法: <code>CanvasRenderingContext2D.createPattern( img, repetition )</code></p>
<p>描述:</p>
<ol>
<li>该方法表示使用图片来填充的设置方法. 需要两个参数, 一个是图片, 一个是重复的方式.</li>
<li>图片允许是 img 标签, 图片, canvas 等对象</li>
<li>可选择的重复方式与 CSS 一致. 有: repeat, repeat-x, repeat-y, no-repeat.</li>
<li>如果是 空或&quot;&quot;, 但不是 undefined, 默认就是 repeat.</li>
</ol>
<p>准备一张图片</p>
<p><img src="./imgs/04d91106ecb1ec84b6708cd9796fc772.jpg" alt=""></p>
<p><strong>案例</strong></p>
<pre><code>    var img = new Image();
    img.src = &#39;imgs/04d91106ecb1ec84b6708cd9796fc772.jpg&#39;;
    img.onload = function () {
        var p = ctx.createPattern( img, &#39;repeat&#39; );
        ctx.fillStyle = p;
        ctx.fillRect( 50, 50, 550, 350 );
    };
</code></pre><p><strong>效果</strong></p>
<p><img src="./imgs/2016-08-13_015514.png" alt=""></p>
<h2 id="-">阴影</h2>
<p>在 Canvas 中还可以给绘制的内容设置阴影. 但是一般不这么用, 因为性能不高.</p>
<p>相关属性:</p>
<ol>
<li><code>CanvasRenderingContext2D.shadowBlur</code> 属性表示模糊程度.</li>
<li><code>CanvasRenderingContext2D.shadowColor</code> 属性表示模糊颜色.</li>
<li><code>CanvasRenderingContext2D.shadowOffsetX</code> 属性表示模糊位置 x 坐标偏移.</li>
<li><code>CanvasRenderingContext2D.shadowOffsetY</code> 属性表示模糊位置 y 坐标偏移.</li>
</ol>
<!--



路径剪切

贝塞尔曲线

合成

像素处理
参考 MDN 和 w3school



-->

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>